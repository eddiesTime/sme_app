# Contents of documentation
## 0. Meta Information

### 0.1 Motivation and relevance of the work
### 0.2 Target Audience

___
## 1. Introduction

### 1.1 What is Flutter?

#### 1.1.1 UI Framework

#### 1.1.2 It's all widgets

#### 1.1.3 Types of Widgets (stateless, stateful, inherited)

### 1.2 What is state?

#### 1.2.1 Definition of state in flutter

#### 1.2.2 ephemeral state & app state

### 1.3 How does flutter react to state changes?

#### 1.3.1 widget tree & element tree

### 1.4 state management

#### 1.4.1 principle of lifting state up

___

## 2. Methodology (sets boundaries for part 3: Results)

### 2.1 Weather App Example

### 2.2 Weather App Widget Tree

### 2.3 Architecture (DDD)

### 2.4 State Management Solution in Application Layer

___

## 3. Results

### 3.1 Patterns in state management solutions (mutable/immutable)

Each example consist of 5 paragraphs: 

* (1) Introduction, 

* (2) mutable/immutable,

* (3) pattern/concept, 

* (4) code implementation in app, 

* (5) benefits/challenges/outcomes


### 3.2 Examples

#### 3.2.1 Stateful Widget

#### 3.2.2 Inherited Widget

#### 3.2.3 ChangenotifierProvider

#### 3.2.4 BLoC (Vanilla) Rxdart

#### 3.2.5 Flutter_bloc

#### 3.2.6 Redux

#### 3.2.7 MobX

#### 3.2.8 States_rebuilder

___

## 4. Discussion (depends on part 3: Results)

* how well did it work out to implement the solution into the architecture?

* how many guides and/or tutorials for the solution can be found?

* how easy is it to learn?

* how much boilerplate needs to be implemented?

* how many lines of code in application and presentation layer

___

## 5. Conclusion (summary of part 4: Discussion)

* use the right tool for the job

* which solution is suited to help with state management in example, small-scale, middle-scale, large-scale applications

___

## 6. References

___

## 7. Bibliography

